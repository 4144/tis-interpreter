(**************************************************************************)
(*                                                                        *)
(*  This file is part of tis-interpreter.                                 *)
(*  Copyright (C) 2016 TrustInSoft                                        *)
(*                                                                        *)
(*  you can redistribute it and/or modify it under the terms of the GNU   *)
(*  General Public License as published by the Free Software              *)
(*  Foundation, version 2.                                                *)
(*                                                                        *)
(*  It is distributed in the hope that it will be useful,                 *)
(*  but WITHOUT ANY WARRANTY; without even the implied warranty of        *)
(*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *)
(*  GNU General Public License version 2 for more details.                *)
(*  (enclosed in the file licences/GPLv2).                                *)
(*                                                                        *)
(**************************************************************************)

open Mkfs_build

let generate_headers fmt h_filename =
    Format.fprintf fmt "\
/* WARNING: file generated by tis-mkfs tool: do not modify. */\n\
#include \"__tis_mkfs.h\"\n\
#include \"%s\"\n\
\n" (Filename.basename h_filename)

let generate_dot_dirs fmt =
  let cdot = Char.code '.' in
  Format.fprintf fmt "/* Contents for '.' and '..' */@.";
  Format.fprintf fmt
    "struct dirent fc_dir_dot = {0, 0, 0, 0, {%d, 0}};@." cdot;
  Format.fprintf fmt
    "struct dirent fc_dir_dot_dot = {0, 0, 0, 0, {%d, %d, 0}};\n@." cdot cdot

let generate_other_info fmt next_inode =
  let pp fmt ty name =
    Format.fprintf fmt "%s __tis_%s = TIS_%s;@." ty name name
  in
  pp fmt "uid_t" "uid";
  pp fmt "gid_t" "gid";
  pp fmt "uid_t" "euid";
  pp fmt "gid_t" "egid";
  Format.fprintf fmt "\n\n";
  Format.fprintf fmt "int __tis_next_inode = %d;@.@." next_inode

let generate_functions fmt nb_max_files nb_max_dirs =
  let generate_fun fun_name arr_name fmt max =
    Format.fprintf fmt "int %s (const char *path) {@." fun_name;
    Format.fprintf fmt "\
\  //@@ loop pragma UNROLL %d;@.\
\  for (int i = 0; i < %s_nb; i++)@.\
\    if (%s[i].__fc_fullpath && strcmp(%s[i].__fc_fullpath, path) == 0)@.\
\      return i;@." max arr_name arr_name arr_name;
  Format.fprintf fmt "  return -1;@.}@."
  in
  generate_fun "__tis_mkfs_get_file" "__fc_fs_files" fmt nb_max_files;
  generate_fun "__tis_mkfs_get_dir" "__fc_fs_dirs" fmt nb_max_dirs

let pp_mode fmt inode = 
  let open Unix in
  let mode = match Inode.stat inode with
    | None ->
        let mode = "TIS_FILE_MODE" :: [] in
        let mode =
          if Inode.is_file inode then "S_IFREG" :: mode
          else if Inode.is_dir inode then "S_IFDIR" :: mode
          else bug ("neither file nor directory ?")
        in mode
    | Some stat ->
      let perm = stat.st_perm in
      let if_perm flags = ((perm land flags) = flags) in
      let mode = [] in
      let mode = if if_perm 0o001 then "S_IXOTH" :: mode else mode in
      let mode = if if_perm 0o002 then "S_IWOTH" :: mode else mode in
      let mode = if if_perm 0o004 then "S_IROTH" :: mode else mode in
      let mode = if if_perm 0o010 then "S_IXGRP" :: mode else mode in
      let mode = if if_perm 0o020 then "S_IWGRP" :: mode else mode in
      let mode = if if_perm 0o040 then "S_IRGRP" :: mode else mode in
      let mode = if if_perm 0o100 then "S_IXUSR" :: mode else mode in
      let mode = if if_perm 0o200 then "S_IWUSR" :: mode else mode in
      let mode = if if_perm 0o400 then "S_IRUSR" :: mode else mode in
      let mode = match stat.st_kind with
        | S_DIR -> "S_IFDIR" :: mode
        | S_REG -> "S_IFREG" :: mode
        | S_CHR -> "S_IFCHR" :: mode
        | S_BLK -> "S_IFBLK" :: mode
        | S_LNK -> "S_IFLNK" :: mode
        | S_FIFO -> "S_IFIFO" :: mode
        | S_SOCK -> "S_IFSOCK" :: mode
      in mode
  in
  let rec pp fmt l = match l with [] -> ()
  | m :: [] -> Format.pp_print_string fmt m
  | m :: tl -> Format.fprintf fmt "%s@ | %a" m pp tl
  in
  Format.fprintf fmt "@[<hov>%a@]" pp mode

let inode_var_name inode =  Format.sprintf "fc_inode_%d" (Inode.num inode)

let content_name inode =
  if (Inode.is_file inode) then
    Format.sprintf "fc_file_contents_%d" (Inode.num inode)
  else if (Inode.is_dir inode) then
    Format.sprintf "fc_dir_contents_%d" (Inode.num inode)
  else bug ("neither file nor directory ?")

let pp_stat fmt inode =
  let pp_size fmt = match Inode.st_size inode with
  | None -> Format.fprintf fmt "TIS_FILE_SIZE"
  | Some sz -> Format.fprintf fmt "%d" sz
  in
  let pp fmt =
    Format.fprintf fmt "@,0,  /* ID of device containing file */";
    Format.fprintf fmt "@,%d,  /* inode number */" (Inode.num inode);
    Format.fprintf fmt "@,%a,  /* t_mode = kind + protection */" pp_mode inode;
    Format.fprintf fmt "@,1,  /* number of hard links */";
    Format.fprintf fmt "@,TIS_FILE_UID,  /* user ID of owner */";
    Format.fprintf fmt "@,TIS_FILE_GID,  /* group ID of owner */";
    Format.fprintf fmt "@,0,  /* device ID (if special file) */";
    Format.fprintf fmt "@,%t,  /* total size, in bytes */" pp_size;
    Format.fprintf fmt "@,0,  /* time of last access */";
    Format.fprintf fmt "@,0,  /* time of last modification */";
    Format.fprintf fmt "@,0,  /* time of last status change */";
    Format.fprintf fmt "@,1,  /* st_blksize field */";
    Format.fprintf fmt "@,1  /* st_blocks field */";
  in
  Format.fprintf fmt "/* inode of '%s' */@." (Inode.c_name inode);
  Format.fprintf fmt "@[<v2>struct stat %s = {%t@]@,};@."
    (inode_var_name inode)
    pp

let pp_file_content fmt inode =
  Format.fprintf fmt "/* Contents of file '%s' */@." (Inode.c_name inode);
  let array_name = Format.sprintf "%s_array" (content_name inode) in
  let fun_name = content_name inode in
  let pp_fun_decl fmt =
    Format.fprintf fmt "unsigned char * %s (void)" fun_name
  in
  match Inode.file_source inode with
  | Mkfs_build.SrcNone -> 
      Format.fprintf fmt "%t { return NULL; }@." pp_fun_decl
  | Mkfs_build.SrcGenericFile { gc_size; gc_min; gc_max} ->
    Format.fprintf fmt "extern unsigned char %s[%d];@."
      array_name gc_size;
      let pp_body fmt =
        Format.fprintf fmt "@,//@@ loop pragma UNROLL %d;" gc_size;
        Format.fprintf fmt "@,for (int i = 0; i < %d; i++)" gc_size;
        Format.fprintf fmt
          "@,  %s[i] = Frama_C_unsigned_char_interval (%d, %d);"
          array_name gc_min gc_max;
        Format.fprintf fmt "@,return %s;" array_name
      in
    Format.fprintf fmt "@[<v2>unsigned char * %s (void) {%t@]@,}@."
    fun_name pp_body
  | Mkfs_build.SrcLocal (src_name, _) ->
    let pp_chars fmt =
      let chin = open_in_bin src_name in
      begin
        try
          begin
            while true do
              let c = input_char chin in
              Format.fprintf fmt "@ %d," (Char.code c);
            done;
          end
        with End_of_file ->
          Format.fprintf fmt "@ 0@]";
      end
    in
    Format.fprintf fmt "@[<hov2>unsigned char %s[] = {%t@]@,};@."
      array_name (* Inode.st_size inode *) pp_chars;
    Format.fprintf fmt "@[<v2>%t {@,return %s;@]@,}@." 
      pp_fun_decl array_name

let pp_dir_content inode fmt i dirent_inode =
  let c_name = Inode.c_name inode in
  let d = Inode.num inode in
  let name = Filename.basename (Inode.c_name dirent_inode) in
  Format.fprintf fmt 
    "/* Entry %d for '%s' in directory '%s' */@." i name c_name;
  let pp_name fmt =
    String.iter (fun c -> Format.fprintf fmt "%d,@ " (Char.code c)) name
  in
  Format.fprintf fmt "@[<v2>struct dirent fc_dir_%d_%d = {\
    @,%d, /* inode number */\
    @,0, /* offset to the next dirent */\
    @,0, /* length of this record */\
    @,DT_UNKNOWN, /* type of file */\
    @,@[{%t@]0} /* name = %s */\
    @]@,};@." d i (Inode.num dirent_inode) pp_name name

let pp_dirent_array fmt inode contents =
  let pp_elem fmt i dirent_inode =
    let name = Filename.basename (Inode.c_name dirent_inode) in
    Format.fprintf fmt "@,&fc_dir_%d_%d, /* %s */" (Inode.num inode) i name
  in
  let pp fmt = Array.iteri (pp_elem fmt) contents in
  Format.fprintf fmt "/* Contents of directory '%s' */@." (Inode.c_name inode);
  Format.fprintf fmt 
    "@[<v2>struct dirent *fc_dir_contents_%d[] = "  (Inode.num inode);
  Format.fprintf fmt "{@,&fc_dir_dot,@,&fc_dir_dot_dot,%t@,0@]@,};@." pp

let pp_fs_entries is_dir fmt inodes =
  let addr = if is_dir then "" else "&" in
  let pp_fs_entry fmt inode =
    let c_name = Inode.c_name inode in
    Format.fprintf fmt "@,@[{\"%s\", &%s, %s%s}@],"
      c_name (inode_var_name inode) addr (content_name inode)
  in List.iter (pp_fs_entry fmt) inodes

let pp_inode fmt (file_inodes, dir_inodes) _name inode inodes =
  pp_stat fmt inode;
  if Inode.is_dir inode then
    begin
      let elements = Array.of_list inodes in
      Array.iteri (pp_dir_content inode fmt) elements;
      pp_dirent_array fmt inode elements;
      file_inodes, inode :: dir_inodes
    end
  else if Inode.is_file inode then
    begin
      assert (inodes = []);
      pp_file_content fmt inode;
      inode :: file_inodes, dir_inodes
      end
  else bug ("neither file nor directory ?")

let pp_c_file ~nb_max_files ~nb_max_dirs h_filename fmt fs =
  generate_headers fmt h_filename;
  generate_dot_dirs fmt;
  let file_inodes, dir_inodes = fs_fold (pp_inode fmt) ([], []) fs in
  let nb_files = List.length file_inodes in
  let nb_dirs = List.length dir_inodes in
  let nb_max_files = match nb_max_files with None -> nb_files | Some n -> n in
  let nb_max_dirs = match nb_max_dirs with None -> nb_dirs | Some n -> n in

  Format.fprintf fmt "/* List of files */@.";
  Format.fprintf fmt
    "@[<v2>struct __fc_fs_file __fc_fs_files[%d] = {%a@]@,};@."
    nb_max_files (pp_fs_entries false) file_inodes;
  Format.fprintf fmt "int __fc_fs_files_nb = %d;@." nb_files;
  Format.fprintf fmt "int __fc_fs_files_nb_max = %d;@." nb_max_files;

  Format.fprintf fmt "/* List of directories */@.";
  if nb_max_dirs > 0 then
    Format.fprintf fmt
      "@[<v2>struct __fc_fs_dir __fc_fs_dirs[%d] = {%a@]@,};@."
      nb_max_dirs (pp_fs_entries true) dir_inodes
  else (* avoid array with length 0 *)
    Format.fprintf fmt
      "@[<v2>struct __fc_fs_dir __fc_fs_dirs[1];@.";
  Format.fprintf fmt "int __fc_fs_dirs_nb = %d;@." nb_dirs;
  Format.fprintf fmt "int __fc_fs_dirs_nb_max = %d;@." nb_max_dirs;

  generate_functions fmt nb_max_files nb_max_dirs;
  generate_other_info fmt (fs_next_inode_num fs);
  ()

let pp_h_file h_filename =
  let chout =
    try open_out h_filename
    with Sys_error msg -> Mkfs_build.error "bad output file: %s" msg
  in
  let fmt = Format.formatter_of_out_channel chout in
  Format.fprintf fmt "\
/* This file is generated by tis-mkfs tool only the first time.\n\
   It may be modified to adjust parameters. It won't be erased.\n\
   It can be removed to restore the default values. */\n\
\n\
/* The default value for uid, gid, etc are the current one.\n\
 * Use the macros below to give other values.\n\
 */\n";
  Format.fprintf fmt "#define TIS_uid %d\n" (Unix.getuid ());
  Format.fprintf fmt "#define TIS_euid %d\n" (Unix.geteuid ());
  Format.fprintf fmt "#define TIS_gid %d\n" (Unix.getgid ());
  Format.fprintf fmt "#define TIS_egid %d\n" (Unix.getegid ());
  Format.fprintf fmt "\n";
  Format.fprintf fmt "/* The file and directory owner: */\n";
  Format.fprintf fmt "#define TIS_FILE_UID %d\n" (Unix.getuid ());
  Format.fprintf fmt "#define TIS_FILE_GID %d\n" (Unix.getgid ());
  Format.fprintf fmt "\n\
/* TIS_FILE_MODE defines the default permission for the files.\n\
*/\n\
#define TIS_FILE_MODE (S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH)\n\
\n\
/* TIS_FILE_SIZE is the default size for unknown files.\n\
 * You can change it here, or initilize it from you main function.\n\
 * For instance, to give a size between 100 and 200 to the 'unknown.txt' file:\n\
 *\n\
 * int i = __tis_mkfs_get_file (\"unknown.txt\");\n\
 * assert (i != -1);\n\
 * __fc_fs_files[i].__fc_stat->st_size = Frama_C_interval (100, 200);\n\
 */\n\
#define TIS_FILE_SIZE 100\n\
";
  close_out chout

let export ~nb_max_files ~nb_max_dirs c_filename fs =
  let chout =
    try open_out c_filename
    with Sys_error msg -> Mkfs_build.error "bad output file: %s" msg;
  in
  let fmt = Format.formatter_of_out_channel chout in
  let filename = Filename.chop_suffix c_filename ".c" in
  let h_filename = filename ^ ".h" in
  if Sys.file_exists h_filename then
    Format.printf "[tis-mkfs] using existing %s configuration file.@." h_filename
  else
    begin
      Format.printf "[tis-mkfs] generating %s configuration file.@." h_filename;
      pp_h_file h_filename
    end;
  Format.printf "[tis-mkfs] generating %s file.@." c_filename;
  pp_c_file ~nb_max_files ~nb_max_dirs h_filename fmt fs;
  close_out chout
